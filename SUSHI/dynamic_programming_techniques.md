# 동적 계획법 테크닉
## 반복적(iterative) 동적 계획법
 - 부분 문제 간의 의존성을 파악하기 쉬울 경우 재귀함수 대신 반복문을 이용해서 동적 계획법 구현 가능
 
> 피보나치 수열(재귀적)

```c++
int fib(int n)
{
  if (seq[n] == -1)
    seq[n] = fib(n-1) + fib(n-2);
  return seq[n];
}
```
 
> 피보나치 수열(반복적)

```c++
for (int i = 2; i <= n; i++)
  seq[i] = seq[i-1] + seq[i-2];
```

## 슬라이딩 윈도를 이용한 공간 복잡도 줄이기
 - 부분문제의 수가 많은 경우, 각각의 답을 모두 기억하기에는 메모리가 부족한 경우가 있을 수 있음
 - 새로운 값을 계산할 때 과거 계산 결과 중 일부만이 필요한 경우에는 필요한 부분만을 메모리에 저장해서 사용할 수 있음
 - 반복적 동적 계획법에서 사용 가능
   - 재귀적으로 구현하는 경우에는 각 부분 문제가 계산되는 순서가 일정하지 않기 때문

> 피보나치 수열(슬라이딩 윈도)

```c++
int fib(int n)
{
  if (n <= 1)
    return n;
  /* 배열 크기가 2이면 충분하지만 굳이 3을 사용
     교재에서는 혹시 모를 실수를 방지하기 위해 1씩 더 크게 잡아주는 습관을 가지기를 권장 */
  int seq[3] = {0, 1, };
  for (int i = 2; i <= n; i++)
    seq[i%3] = seq[(i-1)%3] + seq[(i-2)%3];
  return seq[n%3];
}
```

## 행렬 거듭제곱을 이용한 동적 계획법 (skip)

## 반복적 vs 재귀적

| 반복적 동적 계획법 | 재귀적 동적 계획법 |
| --- | --- |
| 좀 더 직관적인 구현 | 구현이 좀 더 비직관적임 |
| 부분 문제 간 의존 관계나 계산 순서에 대해 고민할 필요 없음 | 부분 문제 간 의존 관계를 고려해 계산되는 순서를 고민해야 함 |
| 전체 부분 문제 중 일부의 답만 필요할 경우 더 빠르게 동작 | 모든 부분문제의 답이 필요한 경우 재귀호출에 따른 부하가 없어 좀 더 빠르게 동작 |
| 슬라이딩 윈도 기법을 사용할 수 없음 | 슬라이딩 윈도 기법 사용 가능 |
| stack overflow 발생 가능 | |
| | 구현이 대개 더 짧음 |
